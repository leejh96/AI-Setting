# Backend Architecture Patterns (백엔드 아키텍처 패턴)

마이크로서비스, 이벤트 기반 아키텍처 및 확장성 패턴 (2025).

## 모놀리스 vs 마이크로서비스

### 모놀리식 아키텍처 (Monolithic)

```
┌─────────────────────────────────┐
│      단일 애플리케이션          │
│                                 │
│  ┌─────────┐  ┌──────────┐      │
│  │  Users  │  │ Products │      │
│  └─────────┘  └──────────┘      │
│  ┌─────────┐  ┌──────────┐      │
│  │ Orders  │  │ Payments │      │
│  └─────────┘  └──────────┘      │
│                                 │
│       단일 데이터베이스         │
└─────────────────────────────────┘
```

**장점:**
- 개발 및 배포 단순성
- 로컬 테스트 용이
- 코드베이스 통합
- 강력한 일관성 (ACID 트랜잭션)

**단점:**
- 강한 결합도 (Tight coupling)
- 확장성의 한계 (전체 스케일링 필요)
- 배포 리스크 (하나의 버그가 전체 영향)
- 기술 스택 종속

**사용 시기:** 스타트업, MVP, 소규모 팀, 도메인 경계가 불명확할 때

### 마이크로서비스 아키텍처 (Microservices)

```
┌──────────┐   ┌──────────┐   ┌──────────┐   ┌──────────┐
│  User    │   │ Product  │   │  Order   │   │ Payment  │
│ Service  │   │ Service  │   │ Service  │   │ Service  │
└────┬─────┘   └────┬─────┘   └────┬─────┘   └────┬─────┘
     │              │              │              │
  ┌──▼──┐        ┌──▼──┐        ┌──▼──┐        ┌──▼──┐
  │  DB │        │  DB │        │  DB │        │  DB │
  └─────┘        └─────┘        └─────┘        └─────┘
```

**장점:**
- 독립적 배포 가능
- 기술 스택 유연성 (Polyglot)
- 장애 격리 (Fault isolation)
- 개별 서비스 확장 용이

**단점:**
- 배포 및 운영 복잡성
- 분산 시스템의 난제 (네트워크 지연, 부분 실패)
- 데이터 일관성 (결과적 일관성)

**사용 시기:** 대규모 팀, 명확한 도메인 경계, 독립적 확장이 필요할 때

## 마이크로서비스 패턴

### 서비스별 데이터베이스 패턴 (Database per Service)

**개념:** 각 마이크로서비스는 자신의 데이터베이스를 소유하며, 다른 서비스의 DB에 직접 접근하지 않습니다.

```
User Service    → User DB (PostgreSQL)
Product Service → Product DB (MongoDB)
Order Service   → Order DB (MySQL)
```

**이점:**
- 서비스 결합도 감소
- 서비스 목적에 맞는 DB 기술 선택 가능 (MySQL, Postgres, Mongo 등)

**과제:**
- 서비스 간 조인 불가 (API 조합 필요)
- 분산 트랜잭션 관리 필요 (Saga 등)

### API 게이트웨이 패턴

```
Client
  │
  ▼
┌─────────────────┐
│  API Gateway    │  - 인증(Auth)
│  (Kong/NGINX)   │  - 속도 제한(Rate limiting)
└────────┬────────┘  - 라우팅
         │
    ┌────┴────┬────────┬────────┐
    ▼         ▼        ▼        ▼
  User    Product   Order   Payment
 Service  Service  Service  Service
```

**주요 역할:**
- 요청 라우팅 및 프로토콜 변환
- 공통 관심사 처리 (인증, 로깅, SSL)
- 캐싱 및 응답 집계

### 서킷 브레이커 패턴 (Circuit Breaker)

**개념:** 장애가 발생한 서비스로의 호출을 차단하여 연쇄 장애(Cascade Failure)를 방지합니다.

**상태:**
- **Closed:** 정상 상태, 요청 통과
- **Open:** 장애 임계치 초과, 요청 즉시 차단 (Fail fast)
- **Half-Open:** 복구 확인을 위해 일부 요청 허용

### 사가 패턴 (Saga - 분산 트랜잭션)

분산 환경에서 장기 실행 트랜잭션을 관리하는 방법입니다.

1. **Choreography (안무):** 각 서비스가 이벤트를 발행하고 구독하여 다음 단계 트리거
2. **Orchestration (지휘):** 중앙 오케스트레이터가 각 서비스에 명령 전달

실패 시 **보상 트랜잭션(Compensating Transaction)**을 실행하여 이전 단계를 롤백합니다.

## 이벤트 기반 아키텍처 (Event-Driven Architecture)

### 이벤트 소싱 (Event Sourcing)

**개념:** 현재 상태가 아닌, 상태를 변경한 '이벤트'들의 순차적 기록을 저장합니다.

```typescript
// 전통적 방식: 현재 상태 저장
{ id: '1', balance: 500 }

// 이벤트 소싱: 이벤트 로그 저장
[
  { type: 'AccountCreated', id: '1', time: '...' },
  { type: 'Deposited', amount: 1000, time: '...' },
  { type: 'Withdrawn', amount: 500, time: '...' }
]
```

**이점:** 완벽한 감사 추적(Audit trail), 시점 조회(Time-travel), 디버깅 용이성

### 메시지 브로커 활용

- **Kafka:** 대용량 이벤트 스트리밍, 로그 집계, CDC
- **RabbitMQ:** 복잡한 라우팅이 필요한 작업 큐

## CQRS (명령과 조회의 책임 분리)

**개념:** 쓰기(Command) 모델과 읽기(Query) 모델을 물리적/논리적으로 분리합니다.

```
Write Side (명령):               Read Side (조회):
CreateOrder                      GetOrder
UpdateOrder                      ListOrders
  ↓                                ↑
┌─────────┐                    ┌──────────┐
│ Write   │ → 이벤트 동기화  → │  Read    │
│  DB     │     (Async)        │   DB     │
│(MySQL)  │                    │(MongoDB) │
└─────────┘                    └──────────┘
```

**이점:**
- 읽기/쓰기 부하에 따른 개별 최적화 및 확장
- 단순화된 쿼리 모델 (복잡한 조인 제거)

## 확장성 패턴

### 수평적 확장 (Scale Out)
로드 밸런서를 통해 트래픽을 여러 서버 인스턴스로 분산합니다.

### 데이터베이스 샤딩 (Sharding)
대용량 데이터를 여러 DB 인스턴스에 분할 저장합니다.
- **Range-based:** ID 범위나 날짜 기준 분할
- **Hash-based:** 해시 함수를 이용해 균등 분배

## 아키텍처 결정 매트릭스

| 패턴 | 사용 시기 | 복잡도 | 이점 |
|------|-----------|--------|------|
| **모놀리스** | 소규모, 초기 단계 | 낮음 | 빠르고 단순함 |
| **마이크로서비스** | 대규모, 도메인 확실 | 높음 | 독립 배포, 유연성 |
| **이벤트 기반** | 비동기 워크플로우 | 중간 | 결합도 감소, 확장성 |
| **CQRS** | 읽기/쓰기 패턴 상이 | 높음 | 성능 최적화 |

## 아키텍처 체크리스트
- [ ] 명확한 서비스 경계 (DDD)
- [ ] 서비스별 독립적인 데이터베이스 (공유 DB 금지)
- [ ] API 게이트웨이 도입
- [ ] 서킷 브레이커 적용
- [ ] 비동기 통신 우선 (Kafka/RabbitMQ)
- [ ] 분산 추적 (Distributed Tracing) 도입
- [ ] 모든 서비스에 대한 헬스 체크
